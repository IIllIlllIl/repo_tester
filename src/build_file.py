import subprocess
from pathlib import Path
import sys
from src.reader import FileOperator


class Builder:
    """
    Build files with assertions and imports

    Attributes:
        method_assertions (dict): All assertions for each method

    Methods:
        add_method_assertions(method_name, assertions): Overwrite assertions for a method
        generate_test_file(): Generate test functions
        write_down_test(output, imports): Write down file with functions and imports
        report_pytest(output): Run pytest and report the execution trace
        merge(file_contents): Merge multiple test functions into one test file
        remove_imports(content, package_name): Remove import lines generated by LLM
    """
    def __init__(self):
        self.method_assertions = {}

    def add_method_assertions(self, method_name, assertions):
        self.method_assertions[method_name] = assertions

    def generate_test_file(self):
        test_content = ""

        for method_name, assertions in self.method_assertions.items():
            test_function_name = f"test_{method_name}"
            test_content += f"def {test_function_name}():\n"
            for assertion in assertions:
                test_content += f"    {assertion}\n"
            test_content += "\n"

        return test_content

    def write_down_test(self, output, imports=""):
        print(f"Writing {len(self.method_assertions)} tests to {output}")
        file = self.generate_test_file()
        file = imports + "\n\n" + file
        FileOperator.write_file(output, file)

    @staticmethod
    def report_pytest(output):
        file_path = Path(output)
        if not file_path.exists():
            raise FileNotFoundError(f"Test file write failed: {output}")

        # Build pytest cmd
        pytest_cmd = [
            sys.executable,
            "-m",
            "pytest",
            "-v",
            "-s",
            "-ra",
            "--tb=long",
            "--durations=0",
            str(file_path)
        ]

        try:
            print("Running tests...")
            result = subprocess.run(
                pytest_cmd,
                capture_output=True,
                text=True,
                check=False
            )

            # Print pytest output
            print("PYTEST STDOUT:")
            print(result.stdout)
            print("PYTEST STDERR:")
            print(result.stderr)

        except subprocess.SubprocessError as e:
            print(f"Unexpected error happened when running pytest: {e}")
        except Exception as e:
            print(f"Unexpected error: {e}")

    @staticmethod
    def merge(file_contents):
        import_statements = set()
        from_imports = set()
        non_import_code = []
        for content in file_contents:
            lines = content.split('\n')
            current_code = []

            for line in lines:
                stripped = line.strip()
                if stripped.startswith('import ') or stripped.startswith('from '):
                    import_statements.add(stripped) if stripped.startswith('import ') else from_imports.add(stripped)
                else:
                    current_code.append(line)

            non_import_code.append('\n'.join(current_code))

        sorted_imports = []
        sorted_imports.extend(sorted(import_statements))
        sorted_imports.extend(sorted(from_imports))

        final_imports = '\n'.join(sorted_imports)
        final_code = f"{final_imports}\n\n" + '\n\n'.join(non_import_code).strip()

        return final_code

    @staticmethod
    def remove_imports(content, package_name):
        lines = content.split('\n')
        result_lines = []
        skip_next = False

        for i, line in enumerate(lines):
            stripped = line.strip()
            if not stripped or stripped.startswith('#'):
                result_lines.append(line)
                continue

            if stripped.startswith('import ') and package_name in stripped:
                continue
            if stripped.startswith('from ') and package_name in stripped:
                if stripped.endswith('('):
                    skip_next = True
                continue

            if skip_next:
                if ')' in stripped:
                    skip_next = False
                continue

            result_lines.append(line)

        return '\n'.join(result_lines)
